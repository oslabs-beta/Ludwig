import _without from "lodash/without";
import _pick from "lodash/pick";
import _keys from "lodash/keys";
import _isNil from "lodash/isNil";
import _isFunction from "lodash/isFunction";
import _isEmpty from "lodash/isEmpty";
import _difference from "lodash/difference";
import _defaults from "lodash/defaults";
import _assign from "lodash/assign";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

import React from "react";
import * as Events from "./events";
import isEqual from "react-fast-compare";
import { VictoryTransition } from "../victory-transition/victory-transition";

// DISCLAIMER:
// This file is not currently tested, and it is first on the list of files
// to refactor in our current refactoring effort. Please do not make changes
// to this file without manual testing and/or refactoring and adding tests.
var datumHasXandY = function (datum) {
  return !_isNil(datum._x) && !_isNil(datum._y);
}; //  used for checking state changes. Expected components can be passed in via options


var defaultComponents = [{
  name: "parent",
  index: "parent"
}, {
  name: "data"
}, {
  name: "labels"
}];
export function addEvents(WrappedComponent) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  // @ts-expect-error "TS2545: A mixin class must have a constructor with a single rest parameter of type 'any[]'."
  var AddEventsMixin = /*#__PURE__*/function (_WrappedComponent) {
    _inherits(AddEventsMixin, _WrappedComponent);

    var _super = _createSuper(AddEventsMixin);

    function AddEventsMixin(props) {
      var _this;

      _classCallCheck(this, AddEventsMixin);

      _this = _super.call(this, props);
      _this.state = {};
      _this.getEventState = Events.getEventState.bind(_assertThisInitialized(_this));
      _this.getScopedEvents = Events.getScopedEvents.bind(_assertThisInitialized(_this));

      _this.getEvents = function (p, target, eventKey) {
        return Events.getEvents.call(_assertThisInitialized(_this), p, target, eventKey, _this.getScopedEvents);
      };

      _this.externalMutations = _this.getExternalMutations(_this.props);
      _this.calculatedState = _this.getStateChanges(_this.props);
      _this.globalEvents = {};
      _this.prevGlobalEventKeys = [];
      _this.boundGlobalEvents = {};

      _this.cacheValues(_this.getCalculatedValues(props));

      return _this;
    }

    _createClass(AddEventsMixin, [{
      key: "shouldComponentUpdate",
      value: function shouldComponentUpdate(nextProps) {
        var externalMutations = this.getExternalMutations(nextProps); // @ts-expect-error "Property 'animating' does not exist on type EventMixinCommonProps"

        var animating = this.props.animating || this.props.animate;
        var newMutation = !isEqual(externalMutations, this.externalMutations);

        if (animating || newMutation) {
          this.cacheValues(this.getCalculatedValues(nextProps));
          this.externalMutations = externalMutations;
          this.applyExternalMutations(nextProps, externalMutations);
          return true;
        }

        var calculatedState = this.getStateChanges(nextProps);

        if (!isEqual(this.calculatedState, calculatedState)) {
          this.cacheValues(this.getCalculatedValues(nextProps));
          return true;
        }

        if (!isEqual(this.props, nextProps)) {
          this.cacheValues(this.getCalculatedValues(nextProps));
          return true;
        }

        return false;
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this2 = this;

        var globalEventKeys = _keys(this.globalEvents);

        globalEventKeys.forEach(function (key) {
          return _this2.addGlobalListener(key);
        });
        this.prevGlobalEventKeys = globalEventKeys;
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        var _this3 = this;

        var calculatedState = this.getStateChanges(prevProps);
        this.calculatedState = calculatedState;

        var globalEventKeys = _keys(this.globalEvents);

        var removedGlobalEventKeys = _difference(this.prevGlobalEventKeys, globalEventKeys);

        removedGlobalEventKeys.forEach(function (key) {
          return _this3.removeGlobalListener(key);
        });

        var addedGlobalEventKeys = _difference(globalEventKeys, this.prevGlobalEventKeys);

        addedGlobalEventKeys.forEach(function (key) {
          return _this3.addGlobalListener(key);
        });
        this.prevGlobalEventKeys = globalEventKeys;
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        var _this4 = this;

        this.prevGlobalEventKeys.forEach(function (key) {
          return _this4.removeGlobalListener(key);
        });
      }
    }, {
      key: "addGlobalListener",
      value: function addGlobalListener(key) {
        var _this5 = this;

        var boundListener = function (event) {
          var listener = _this5.globalEvents[key];
          return listener && listener(Events.emulateReactEvent(event));
        };

        this.boundGlobalEvents[key] = boundListener;
        window.addEventListener(Events.getGlobalEventNameFromKey(key), boundListener);
      }
    }, {
      key: "removeGlobalListener",
      value: function removeGlobalListener(key) {
        window.removeEventListener(Events.getGlobalEventNameFromKey(key), this.boundGlobalEvents[key]);
      } // compile all state changes from own and parent state. Order doesn't matter, as any state
      // state change should trigger a re-render

    }, {
      key: "getStateChanges",
      value: function getStateChanges(props) {
        var _this6 = this;

        if (!this.hasEvents) {
          return {};
        }

        var getState = function (key, type) {
          var result = _defaults({}, _this6.getEventState(key, type), _this6.getSharedEventState(key, type));

          return _isEmpty(result) ? undefined : result;
        };

        var components = options.components || defaultComponents;
        var stateChanges = components.map(function (component) {
          if (!props.standalone && component.name === "parent") {
            // don't check for changes on parent props for non-standalone components
            return undefined;
          }

          return component.index !== undefined ? getState(component.index, component.name) : _this6.dataKeys.map(function (key) {
            return getState(key, component.name);
          }).filter(Boolean);
        }).filter(Boolean);
        return stateChanges;
      }
    }, {
      key: "applyExternalMutations",
      value: function applyExternalMutations(props, externalMutations) {
        if (!_isEmpty(externalMutations)) {
          var callbacks = props.externalEventMutations.reduce(function (memo, mutation) {
            memo = _isFunction(mutation.callback) ? memo.concat(mutation.callback) : memo;
            return memo;
          }, []);
          var compiledCallbacks = callbacks.length ? function () {
            callbacks.forEach(function (c) {
              return c();
            });
          } : undefined;
          this.setState(externalMutations, compiledCallbacks);
        }
      }
    }, {
      key: "getCalculatedValues",
      value: function getCalculatedValues(props) {
        var sharedEvents = props.sharedEvents;
        var components = WrappedComponent.expectedComponents;
        var componentEvents = Events.getComponentEvents(props, components);
        var getSharedEventState = sharedEvents && _isFunction(sharedEvents.getEventState) ? sharedEvents.getEventState : function () {
          return undefined;
        };
        var baseProps = this.getBaseProps(props, getSharedEventState);

        var dataKeys = _keys(baseProps).filter(function (key) {
          return key !== "parent";
        });

        var hasEvents = props.events || props.sharedEvents || componentEvents;
        var events = this.getAllEvents(props);
        return {
          componentEvents: componentEvents,
          getSharedEventState: getSharedEventState,
          baseProps: baseProps,
          dataKeys: dataKeys,
          hasEvents: hasEvents,
          events: events
        };
      }
    }, {
      key: "getExternalMutations",
      value: function getExternalMutations(props) {
        var sharedEvents = props.sharedEvents,
            externalEventMutations = props.externalEventMutations;
        return _isEmpty(externalEventMutations) || sharedEvents ? undefined : Events.getExternalMutations(externalEventMutations, this.baseProps, this.state);
      }
    }, {
      key: "cacheValues",
      value: function cacheValues(obj) {
        var _this7 = this;

        _keys(obj).forEach(function (key) {
          _this7[key] = obj[key];
        });
      }
    }, {
      key: "getBaseProps",
      value: function getBaseProps(props, getSharedEventState) {
        getSharedEventState = getSharedEventState || this.getSharedEventState.bind(this);
        var sharedParentState = getSharedEventState("parent", "parent");
        var parentState = this.getEventState("parent", "parent");

        var baseParentProps = _defaults({}, parentState, sharedParentState);

        var parentPropsList = baseParentProps.parentControlledProps;
        var parentProps = parentPropsList ? _pick(baseParentProps, parentPropsList) : {};

        var modifiedProps = _defaults({}, parentProps, props);

        return typeof WrappedComponent.getBaseProps === "function" ? WrappedComponent.getBaseProps(modifiedProps) : {};
      }
    }, {
      key: "getAllEvents",
      value: function getAllEvents(props) {
        if (Array.isArray(this.componentEvents)) {
          var _this$componentEvents;

          return Array.isArray(props.events) ? (_this$componentEvents = this.componentEvents).concat.apply(_this$componentEvents, _toConsumableArray(props.events)) : this.componentEvents;
        }

        return props.events;
      }
    }, {
      key: "getComponentProps",
      value: function getComponentProps(component, type, index) {
        var name = this.props.name || WrappedComponent.role;
        var key = this.dataKeys && this.dataKeys[index] || index;
        var id = "".concat(name, "-").concat(type, "-").concat(key);
        var baseProps = this.baseProps[key] && this.baseProps[key][type] || this.baseProps[key];

        if (!baseProps && !this.hasEvents) {
          return undefined;
        }

        if (this.hasEvents) {
          var baseEvents = this.getEvents(this.props, type, key);

          var componentProps = _defaults({
            index: index,
            key: id
          }, this.getEventState(key, type), this.getSharedEventState(key, type), component.props, baseProps, {
            id: id
          });

          var events = _defaults({}, Events.getPartialEvents(baseEvents, key, componentProps), componentProps.events);

          return _assign({}, componentProps, {
            events: events
          });
        }

        return _defaults({
          index: index,
          key: id
        }, component.props, baseProps, {
          id: id
        });
      }
    }, {
      key: "renderContainer",
      value: function renderContainer(component, children) {
        var isContainer = component.type && component.type.role === "container";
        var parentProps = isContainer ? this.getComponentProps(component, "parent", "parent") : {};

        if (parentProps.events) {
          this.globalEvents = Events.getGlobalEvents(parentProps.events);
          parentProps.events = Events.omitGlobalEvents(parentProps.events);
        }

        return /*#__PURE__*/React.cloneElement(component, parentProps, children);
      }
    }, {
      key: "animateComponent",
      value: function animateComponent(props, defaultAnimationWhitelist) {
        var _props$animate;

        var animationWhitelist = typeof props.animate === "object" && ((_props$animate = props.animate) === null || _props$animate === void 0 ? void 0 : _props$animate.animationWhitelist) || defaultAnimationWhitelist;
        var Comp = this.constructor;
        return /*#__PURE__*/React.createElement(VictoryTransition, {
          animate: props.animate,
          animationWhitelist: animationWhitelist
        }, /*#__PURE__*/React.createElement(Comp, props));
      } // Used by `VictoryLine` and `VictoryArea`

    }, {
      key: "renderContinuousData",
      value: function renderContinuousData(props) {
        var _this8 = this;

        var dataComponent = props.dataComponent,
            labelComponent = props.labelComponent,
            groupComponent = props.groupComponent;

        var dataKeys = _without(this.dataKeys, "all");

        var labelComponents = dataKeys.reduce(function (memo, key) {
          var labelProps = _this8.getComponentProps(labelComponent, "labels", key);

          if (labelProps && labelProps.text !== undefined && labelProps.text !== null) {
            memo = memo.concat( /*#__PURE__*/React.cloneElement(labelComponent, labelProps));
          }

          return memo;
        }, []);
        var dataProps = this.getComponentProps(dataComponent, "data", "all");
        var children = [/*#__PURE__*/React.cloneElement(dataComponent, dataProps)].concat(_toConsumableArray(labelComponents));
        return this.renderContainer(groupComponent, children);
      }
    }, {
      key: "renderData",
      value: function renderData(props) {
        var _this9 = this;

        var shouldRenderDatum = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : datumHasXandY;
        var dataComponent = props.dataComponent,
            labelComponent = props.labelComponent,
            groupComponent = props.groupComponent;
        var dataComponents = this.dataKeys.reduce(function (validDataComponents, _dataKey, index) {
          var dataProps = _this9.getComponentProps(dataComponent, "data", index);

          if (shouldRenderDatum(dataProps.datum)) {
            validDataComponents.push( /*#__PURE__*/React.cloneElement(dataComponent, dataProps));
          }

          return validDataComponents;
        }, []);
        var labelComponents = this.dataKeys.map(function (_dataKey, index) {
          var labelProps = _this9.getComponentProps(labelComponent, "labels", index);

          if (labelProps.text !== undefined && labelProps.text !== null) {
            return /*#__PURE__*/React.cloneElement(labelComponent, labelProps);
          }

          return undefined;
        }).filter(Boolean);
        var children = [].concat(_toConsumableArray(dataComponents), _toConsumableArray(labelComponents));
        return this.renderContainer(groupComponent, children);
      }
    }]);

    return AddEventsMixin;
  }(WrappedComponent);

  return AddEventsMixin;
}