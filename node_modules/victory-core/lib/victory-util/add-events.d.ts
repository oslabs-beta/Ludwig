import React from "react";
import type { ComponentEvent } from "./events";
import * as Events from "./events";
import { VictoryCommonProps, VictoryDatableProps } from "./common-props";
import { VictoryLabelableProps } from "../types/prop-types";
export declare type MixinOptions = {
    components?: Array<{
        name: string;
        index?: string | number;
    }>;
};
export interface EventMixinCommonProps extends VictoryCommonProps, VictoryDatableProps, VictoryLabelableProps {
}
/**
 * These methods will be implemented by the Mixin,
 * and are accessible to the Wrapped Component.
 *
 * To make your Wrapped Component type-safe, use "interface merging" like so:
 * @example
 *    interface MyComponent extends EventsMixinClass<MyProps> {}
 *    class MyComponent extends React.Component<MyProps> { ... }
 */
export interface EventsMixinClass<TProps> {
    renderContainer(component: React.ReactElement, children: React.ReactElement | React.ReactElement[]): React.ReactElement;
    cacheValues<TThis>(this: TThis, obj: Partial<TThis>): void;
    getEventState: typeof Events.getEventState;
    renderData(props: TProps): any;
    renderContinuousData(props: TProps): any;
    animateComponent(props: TProps, defaultAnimationWhitelist: string[]): React.ReactElement;
    getComponentProps(component: React.ReactElement, type: string, index: number): TProps;
    dataKeys: string[];
}
/**
 * These fields are calculated by the Mixin
 */
export interface EventMixinCalculatedValues {
    componentEvents: Array<ComponentEvent>;
    getSharedEventState: (key: string, value: string) => unknown;
    baseProps: Record<string, object>;
    dataKeys: string[];
    hasEvents: unknown;
    events: unknown;
}
/**
 * These are the common roles that we care about internally.
 */
export declare type VictoryComponentCommonRole = "container" | "group" | "histogram" | "label" | "line" | "portal" | "stack" | "tooltip" | "voronoi";
/**
 * A component can have any "role",
 * but there are certain ones that we actually care about internally
 */
export declare type VictoryComponentRole = VictoryComponentCommonRole | string;
/**
 * Static component fields used by Victory for common behavior
 */
export interface VictoryComponentConfiguration<TProps> {
    getBaseProps?(props: TProps): EventMixinCalculatedValues["baseProps"];
    role?: VictoryComponentRole;
    expectedComponents?: Array<keyof TProps | string>;
    getChildren?: (props: TProps, childComponents?: Array<React.ReactNode>, calculatedProps?: TProps) => void;
    animationWhitelist?: Array<keyof TProps | string>;
}
/**
 * This represents the class itself, including static fields
 */
export interface WrappedComponentClass<TProps> extends VictoryComponentConfiguration<TProps> {
    new (props: TProps): React.Component<TProps>;
}
export declare function addEvents<TBase extends WrappedComponentClass<TProps>, TProps extends EventMixinCommonProps>(WrappedComponent: TBase, options?: MixinOptions): {
    new (props: TProps): {
        state: {};
        getEventState: (eventKey: string | number, namespace: string, childType?: string | undefined) => any;
        getScopedEvents: (events: any, namespace: any, childType: any, baseProps: any) => {};
        getEvents: (p: any, target: any, eventKey: any) => any;
        externalMutations: {} | undefined;
        calculatedState: {};
        globalEvents: {};
        prevGlobalEventKeys: string[];
        boundGlobalEvents: {};
        shouldComponentUpdate(nextProps: TProps): boolean;
        componentDidMount(): void;
        componentDidUpdate(prevProps: any): void;
        componentWillUnmount(): void;
        addGlobalListener(key: any): void;
        removeGlobalListener(key: any): void;
        getStateChanges(props: any): {};
        applyExternalMutations(props: any, externalMutations: any): void;
        getCalculatedValues(props: any): EventMixinCalculatedValues;
        getExternalMutations(props: TProps): {} | undefined;
        cacheValues(obj: any): void;
        getBaseProps(props: any, getSharedEventState: any): Record<string, object>;
        getAllEvents(props: any): any;
        getComponentProps(component: any, type: any, index: any): any;
        renderContainer(component: any, children: any): React.DetailedReactHTMLElement<any, HTMLElement>;
        animateComponent(props: TProps, defaultAnimationWhitelist: string[]): React.ReactElement;
        renderContinuousData(props: TProps): React.DetailedReactHTMLElement<any, HTMLElement>;
        renderData(props: any, shouldRenderDatum?: (datum: any) => boolean): React.DetailedReactHTMLElement<any, HTMLElement>;
        context: unknown;
        setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<TProps>) => {} | Pick<{}, K> | null) | Pick<{}, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callback?: (() => void) | undefined): void;
        render(): React.ReactNode;
        readonly props: Readonly<TProps>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<TProps>, prevState: Readonly<{}>): any;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<TProps>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<TProps>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<TProps>, nextState: Readonly<{}>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<TProps>, nextState: Readonly<{}>, nextContext: any): void;
        componentEvents: ComponentEvent[];
        getSharedEventState: (key: string, value: string) => unknown;
        baseProps: Record<string, object>;
        dataKeys: string[];
        hasEvents: unknown;
        events: unknown;
    };
    getBaseProps?(props: TProps): Record<string, object>;
    role?: string | undefined;
    expectedComponents?: (string | keyof TProps)[] | undefined;
    getChildren?: ((props: TProps, childComponents?: React.ReactNode[] | undefined, calculatedProps?: TProps | undefined) => void) | undefined;
    animationWhitelist?: (string | keyof TProps)[] | undefined;
} & TBase;
//# sourceMappingURL=add-events.d.ts.map